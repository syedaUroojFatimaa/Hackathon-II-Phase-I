# Implementation Plan: In-Memory Python Console Todo App

**Branch**: `001-console-todo-app` | **Date**: 2026-01-06 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-console-todo-app/spec.md`

## Summary

Build a basic in-memory command-line Todo application that supports full CRUD operations (Create, Read, Update, Delete) plus status management and filtering. The application uses a layered architecture with clear separation between CLI, application logic, domain models, and in-memory storage. All operations are deterministic and data exists only during the application session.

**Primary Requirement**: Enable users to manage a todo list through an interactive console interface with add, view, update, delete, mark complete, and filter operations.

**Technical Approach**: Four-layer architecture (CLI → Application → Domain → Storage) using pure Python with no external dependencies. In-memory storage using Python dict for O(1) lookups. Interactive REPL-style interface with menu-driven commands.

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: None (Python standard library only)
**Storage**: In-memory (dict for todos, int counter for ID generation)
**Testing**: Manual testing (Phase I - automated tests in Phase II)
**Target Platform**: Console/Terminal (Windows, Linux, macOS)
**Project Type**: Single project (console application)
**Performance Goals**: Handle 1000 todos without noticeable degradation (<100ms response time)
**Constraints**: No persistence, no external dependencies, single-process execution, fully deterministic
**Scale/Scope**: Single-user, single-session, ~1000 todos maximum

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Phase I Requirements (from Constitution)

✅ **In-Memory Only**: Storage layer uses Python dict, no file I/O, no databases
✅ **Console-Based**: CLI layer handles terminal input/output only, no GUI, no web
✅ **Deterministic**: All operations produce predictable results, no randomness, no external API calls
✅ **No Persistence**: Data cleared when application exits, explicit in requirements (FR-014)

### Core Principles Compliance

✅ **I. Spec-First Development**: Complete spec.md exists with all requirements documented
✅ **II. Phase Isolation**: Phase I only - no web frameworks, no databases, no AI, no cloud dependencies
✅ **III. Traceability**: All features map to functional requirements (FR-001 through FR-015)
✅ **IV. Deterministic-First**: Fully deterministic - no AI, no probabilistic behavior
✅ **V. Technology Stack Discipline**: Python 3.13+ only, matches Phase I stack specification
✅ **VI. Separation of Concerns**: Four-layer architecture with clear boundaries

### Quality Gates

✅ **No Implementation Leakage**: Spec contains no code, only requirements
✅ **Explicit State**: Todo entity fully defined (ID, title, description, status)
✅ **Clear Boundaries**: Each layer has defined responsibilities (see Architecture section)
✅ **No Hidden Dependencies**: Zero external libraries, Python stdlib only

**Gate Status**: ✅ PASSED - All constitution requirements met, no violations

## Project Structure

### Documentation (this feature)

```text
specs/001-console-todo-app/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file - implementation plan
├── research.md          # Phase 0 - architecture patterns and best practices
├── data-model.md        # Phase 1 - Todo entity and state model
├── quickstart.md        # Phase 1 - how to run and use the application
├── contracts/           # Phase 1 - internal API contracts
│   └── todo_service.md  # TodoService interface contract
└── tasks.md             # Phase 2 - generated by /sp.tasks (not yet created)
```

### Source Code (repository root)

```text
src/
├── models/
│   └── todo.py          # Todo entity (dataclass)
├── services/
│   └── todo_service.py  # Business logic and storage
├── cli/
│   ├── parser.py        # Command parsing and validation
│   ├── renderer.py      # Output formatting and display
│   └── app.py           # Main CLI loop and command routing
└── main.py              # Application entry point

tests/
└── manual/
    └── test_scenarios.md # Manual test scenarios (automated tests in Phase II)

pyproject.toml           # UV project configuration
README.md                # Project overview and setup instructions
```

**Structure Decision**: Single project structure selected because this is a standalone console application with no web frontend, no API server, and no mobile components. All code resides in `src/` with clear module separation by layer (models, services, cli). Testing will be manual for Phase I per constitution requirements.

## Architecture

### Layer Responsibilities

**CLI Layer** (`src/cli/`):
- Handles user input from terminal (stdin)
- Parses commands and validates input format
- Routes commands to application layer
- Formats and displays output to terminal (stdout)
- Manages interactive REPL loop
- **Does NOT**: Contain business logic, validate business rules, or access storage directly

**Application Layer** (`src/services/`):
- Validates business rules (e.g., non-empty titles)
- Orchestrates operations on domain entities
- Manages in-memory storage (dict of todos)
- Generates unique IDs for new todos
- Enforces data consistency
- **Does NOT**: Handle user input/output or contain CLI-specific logic

**Domain Layer** (`src/models/`):
- Defines Todo entity structure
- Encapsulates todo state (id, title, description, status)
- Provides immutable data representation
- **Does NOT**: Contain business logic or storage logic

**Storage Layer** (within `TodoService`):
- In-memory dict: `{id: Todo}`
- ID counter for sequential ID generation
- O(1) lookups by ID
- **Does NOT**: Persist to disk or external systems

### Data Flow

```
User Input (terminal)
    ↓
CLI Parser (validates format)
    ↓
CLI App (routes command)
    ↓
TodoService (validates business rules, executes operation)
    ↓
In-Memory Storage (dict)
    ↓
TodoService (returns result)
    ↓
CLI Renderer (formats output)
    ↓
Terminal Output (stdout)
```

### Command Structure

**Interactive Menu**:
```
1. Add Todo
2. View All Todos
3. View Todo by ID
4. Update Todo
5. Delete Todo
6. Mark Complete
7. Mark Incomplete
8. Filter by Status
9. Exit
```

Each command prompts for required inputs and displays results immediately.

### Error Handling Strategy

- **Input Validation**: CLI layer validates format (e.g., numeric IDs)
- **Business Validation**: Service layer validates rules (e.g., non-empty titles)
- **Error Display**: All errors shown as user-friendly messages, no stack traces
- **Graceful Degradation**: Invalid operations leave state unchanged

## Complexity Tracking

> **No violations detected** - Constitution check passed with zero violations. No complexity justification required.

## Phase 0: Research (Complete)

All technical decisions resolved:

**Decision**: Use Python dataclasses for Todo entity
**Rationale**: Built-in, type-safe, immutable by default with frozen=True, no external dependencies
**Alternatives**: Plain dict (less type safety), NamedTuple (less flexible), Pydantic (external dependency - violates Phase I)

**Decision**: Use dict for in-memory storage
**Rationale**: O(1) lookups by ID, built-in, simple, sufficient for 1000 todos
**Alternatives**: List (O(n) lookups), SQLite in-memory (overkill, adds dependency)

**Decision**: Interactive REPL-style CLI
**Rationale**: Better UX than single-command execution, matches "interactive console program" assumption from spec
**Alternatives**: Argument-based CLI (less interactive), TUI library (external dependency)

**Decision**: Sequential integer IDs starting from 1
**Rationale**: Simple, predictable, human-readable, matches spec assumption
**Alternatives**: UUIDs (overkill), random IDs (non-deterministic - violates Phase I)

## Phase 1: Design Artifacts

### Data Model

See [data-model.md](./data-model.md) for complete entity definitions and state transitions.

**Summary**:
- Todo entity with 4 fields: id (int), title (str), description (str), status (str)
- Status values: "pending" | "completed"
- Validation rules: title non-empty, status must be valid enum value
- State transitions: pending ↔ completed (bidirectional)

### API Contracts

See [contracts/todo_service.md](./contracts/todo_service.md) for complete TodoService interface.

**Summary**:
- `add_todo(title, description) -> Todo`
- `get_todo(id) -> Todo | None`
- `get_all_todos() -> list[Todo]`
- `update_todo(id, title, description) -> Todo | None`
- `delete_todo(id) -> bool`
- `mark_complete(id) -> Todo | None`
- `mark_incomplete(id) -> Todo | None`
- `filter_by_status(status) -> list[Todo]`

### Quickstart

See [quickstart.md](./quickstart.md) for setup and usage instructions.

**Summary**:
1. Install Python 3.13+
2. Install UV: `pip install uv`
3. Run: `uv run src/main.py`
4. Follow interactive menu prompts

## Next Steps

1. **Task Breakdown**: Run `/sp.tasks` to generate dependency-ordered implementation tasks
2. **Implementation**: Run `/sp.implement` to execute tasks
3. **Validation**: Manual testing against acceptance scenarios in spec.md
4. **Commit**: Create git commit with all Phase I code

## Notes

- No external dependencies required (Python stdlib sufficient)
- All operations are synchronous (no async needed for Phase I)
- Error messages should be clear and actionable
- Code should be simple and readable (no premature optimization)
- Phase II will add automated tests, persistence, and web API
